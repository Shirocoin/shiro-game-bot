const config = {
  type: Phaser.AUTO,
  width: 480,
  height: 720,
  backgroundColor: '#88cfff',
  physics: {
    default: 'arcade',
    arcade: {
      gravity: { y: 0 },
      debug: false
    }
  },
  scene: {
    preload: preload,
    create: create,
    update: update
  },
  parent: 'game-container',
  scale: {
    mode: Phaser.Scale.FIT,
    autoCenter: Phaser.Scale.CENTER_BOTH
  }
};

const game = new Phaser.Game(config);
if (window.Telegram && window.Telegram.WebApp) {
    Telegram.WebApp.ready();
}

let shiro;
let cursors;
let coins;
let score = 0;
let scoreText;
let shiroHitbox;
let coinDropEvent;
let dropSpeed = 450;
let gameTime = 0;
let timeBar;
let timeStars = [];
let timeMax = 90;
let currentTime = 0;
let gameOver = false;
let gameStarted = false;
let soundEffects = {};
let startButton;
let restartButton;
let moveLeft = false;
let moveRight = false;

function preload() {
  this.load.on('loaderror', function(file) {
    console.error('Error loading asset:', file.src);
  });

  this.load.image('background', 'asset/images/background_base.png');
  this.load.image('shiro', 'asset/images/shiro.png');
  this.load.image('bitcoin', 'asset/bitcoin_medium.png');
  this.load.image('ethereum', 'asset/ethereum_medium.png');
  this.load.image('solana', 'asset/solana_medium.png');
  this.load.image('shiro_coin', 'asset/shiro_medium.png');
  this.load.image('hit', 'asset/shiro_hit_effect.png');
  this.load.image('star', 'asset/images/star.png');
  this.load.image('arrow_left', 'asset/arrow_left_cat.png');
  this.load.image('arrow_right', 'asset/arrow_right_cat.png');
  this.load.image('start_icon', 'asset/start_cat.png');
  this.load.image('restart_icon', 'asset/restart_cat.png');
  this.load.audio('positive', 'asset/coin_positive.ogg');
  this.load.audio('negative', 'asset/coin_negative.ogg');
  this.load.audio('music', 'asset/background_loop.mp3');
  this.load.audio('game_over', 'asset/game_over.ogg');
}

function create() {
  gameOver = false;
  gameStarted = false;
  currentTime = 0;
  score = 0;
  
  if (coinDropEvent) {
      coinDropEvent.remove();
  }

  // Agregar fondo
  const background = this.add.image(240, 360, 'background');
  background.setDisplaySize(480, 720);
  
  // Crear y configurar Shiro
  shiro = this.physics.add.sprite(240, 710, 'shiro');
  shiro.setOrigin(0.5, 1);
  shiro.setDisplaySize(70, 70);
  shiro.setCollideWorldBounds(true);
  
  // Crear hitbox para detección de colisiones
  shiroHitbox = this.physics.add.sprite(shiro.x, shiro.y - 50, null);
  shiroHitbox.setSize(40, 40);
  shiroHitbox.setVisible(false);
  shiroHitbox.body.allowGravity = false;
  shiroHitbox.setImmovable(true);

  // Ajustar propiedades de física de Shiro
  shiro.setBounce(0);
  shiro.setDragX(1000);
  shiro.setMaxVelocity(400);
  shiro.setVelocity(0);
  shiro.setGravityY(0);

  this.time.delayedCall(0, () => {
    if (shiro && shiro.body) {
      shiro.body.setSize(60, 60, true);
      shiro.body.setOffset(20, 40);
    }
  });

  // Configurar grupo de monedas y detección de colisiones
  coins = this.physics.add.group();
  this.physics.add.overlap(shiroHitbox, coins, (sh, coin) => collectCoin.call(this, sh, coin), null, this);
  
  // Configurar controles
  cursors = this.input.keyboard.createCursorKeys();

  // Configurar evento para caída de monedas
  coinDropEvent = this.time.addEvent({
    delay: 1300,
    callback: dropCoin,
    callbackScope: this,
    loop: true
  });

  // Mostrar puntuación
  scoreText = this.add.text(20, 60, 'Puntos: 0', {
    fontSize: '24px',
    fill: '#fff',
    fontFamily: 'Arial',
    stroke: '#000',
    strokeThickness: 2
  });
  
  // Crear barra de estrellas
  timeBar = this.add.group();
  timeStars.forEach(star => {
    if (star && star.destroy) star.destroy();
  });
  timeStars = [];
  for (let i = 0; i < 6; i++) {
    let star = this.add.image(120 + i * 60, 30, 'star')
      .setAlpha(0.2)
      .setDisplaySize(40, 40)
      .setDepth(10);
    timeStars.push(star);
  }

  // Precargar efectos de sonido
  soundEffects = {
    positive: this.sound.add('positive'),
    negative: this.sound.add('negative'),
    gameOver: this.sound.add('game_over')
  };

  // ✅ BOTÓN START - CREAR PRIMERO
  startButton = this.add.image(240, 360, 'start_icon')
    .setDisplaySize(120, 120)
    .setInteractive()
    .setDepth(100);

  // ✅ PAUSAR JUEGO DESDE EL INICIO
  this.physics.pause();
  coinDropEvent.paused = true;

  // ✅ EVENTO DEL BOTÓN START - SIN CONFLICTOS
  startButton.on('pointerdown', () => {
    console.log('¡Botón START presionado!');
    startButton.setVisible(false);
    gameStarted = true;
    this.physics.resume();
    coinDropEvent.paused = false;
    this.sound.play('music', { loop: true, volume: 0.1 });
  });

  // ✅ CONTROLES TÁCTILES - CORREGIDOS
  setupTouchControls(this);

  // ✅ Botones táctiles para móviles
  if (this.sys.game.device.input.touch) {
    const leftButton = this.add.image(60, 660, 'arrow_left')
      .setDisplaySize(80, 80)
      .setInteractive()
      .setDepth(50);

    const rightButton = this.add.image(420, 660, 'arrow_right')
      .setDisplaySize(80, 80)
      .setInteractive()
      .setDepth(50);

    leftButton.on('pointerdown', () => { moveLeft = true; });
    rightButton.on('pointerdown', () => { moveRight = true; });
    leftButton.on('pointerup', () => { moveLeft = false; });
    rightButton.on('pointerup', () => { moveRight = false; });
    leftButton.on('pointerout', () => { moveLeft = false; });
    rightButton.on('pointerout', () => { moveRight = false; });
  }
}

function update() {
  if (gameOver || !gameStarted) return;
  
  // Control de movimiento horizontal
  if (cursors.left.isDown || moveLeft) {
    shiro.setVelocityX(-1100);
  } else if (cursors.right.isDown || moveRight) {
    shiro.setVelocityX(1100);
  } else {
    shiro.setVelocityX(0);
  }

  // Límite visual duro a izquierda y derecha
  if (shiro.x > 435) {
    shiro.setVelocityX(0);
    shiro.x = 435;
  }
  if (shiro.x < 45) {
    shiro.setVelocityX(0);
    shiro.x = 45;
  }

  // Actualizar posición del hitbox invisible
  if (shiroHitbox && shiro) {
    shiroHitbox.x = shiro.x;
    shiroHitbox.y = shiro.y - 50;
  }

  // Aumentar dificultad de forma muy gradual
  if (!gameOver) {
    gameTime += this.game.loop.delta;

    if (gameTime >= 4000) {
      gameTime = 0;
      dropSpeed += 0.3;
      const timeBasedReduction = Math.min(40 + (currentTime / 20) * 5, 60);
      let newDelay = Math.max(coinDropEvent.delay - timeBasedReduction, 20000);

      if (currentTime > 20) {
        newDelay = Math.max(newDelay - 10, 800);
      }

      if (coinDropEvent) {
        coinDropEvent.reset({
          delay: newDelay,
          callback: dropCoin,
          callbackScope: this,
          loop: true
        });
      }
    }
  }

  // TEMPORIZADOR de estrellas
  if (!gameOver) {
    currentTime += this.game.loop.delta / 1000;
    const secondsPerStar = timeMax / timeStars.length;

    for (let i = 0; i < timeStars.length; i++) {
      if (timeStars[i] && currentTime >= secondsPerStar * (i + 1)) {
        timeStars[i].setAlpha(1);
      }
    }

    if (currentTime >= timeMax && !gameOver) {
      endGame.call(this);
    }
  }
}

// ✅ SETUPTOUCH CORREGIDO - SIN ERROR CONTAINS
function setupTouchControls(scene) {
  scene.input.on('pointerdown', (pointer) => {
    if (gameStarted && !gameOver) {
        if (pointer.x < scene.sys.game.config.width / 2) {
            moveLeft = true;
            moveRight = false;
        } else {
            moveRight = true;
            moveLeft = false;
        }
    }
  });

  scene.input.on('pointerup', () => {
    moveLeft = false;
    moveRight = false;
  });

  // ✅ REMOVIDO el pointerout problemático con contains()
}

function dropCoin() {
  if (gameOver) return; 
  
  const shiroWidth = 60;
  const totalPlayableWidth = 400;
  
  let coinCount = 3;
  
  if (currentTime > 30) { 
    coinCount = 5;
  }
  
  if (currentTime > 60) { 
    coinCount = 6;
  }
  
  coinCount = Math.min(coinCount, 5);
  
  const maxPossibleCoins = 11;
  const segmentWidth = totalPlayableWidth / maxPossibleCoins;
  
  const safePathCount = 3;
  const safePaths = [];
  
  for (let i = 0; i < safePathCount; i++) {
    const safeSegment = Math.floor((maxPossibleCoins / (safePathCount + 1)) * (i + 1));
    safePaths.push(safeSegment);
  }
  
  let availableSegments = [];
  for (let i = 0; i < maxPossibleCoins; i++) {
    if (!safePaths.includes(i)) {
      availableSegments.push(i);
    }
  }
  
  Phaser.Utils.Array.Shuffle(availableSegments);
  const selectedSegments = availableSegments.slice(0, Math.min(coinCount, availableSegments.length));
  selectedSegments.sort((a, b) => a - b);
  
  let distributedPositions = [];
  
  for (const segment of selectedSegments) {
    const segmentStart = 40 + (segment * segmentWidth) + 5;
    const segmentEnd = 40 + ((segment + 1) * segmentWidth) - 15;
    const position = Math.floor(segmentStart + (segmentEnd - segmentStart) * 0.5 + 
                               (Math.random() - 0.5) * (segmentEnd - segmentStart) * 0.6);
    distributedPositions.push(position);
  }
  
  for (let i = 0; i < distributedPositions.length; i++) {
    this.time.delayedCall(i * 500, () => {
      if (gameOver) return;
      
      const x = distributedPositions[i];
      const typeRng = Math.random();
      let randomType;

      if (typeRng < 0.25) {
        randomType = 'shiro_coin';
      } else {
        randomType = Phaser.Utils.Array.GetRandom(['bitcoin', 'ethereum', 'solana']);
      }

      const coin = coins.create(x, 0, randomType);
      coin.setVelocityY(dropSpeed);
      coin.setDisplaySize(30, 30);
      coin.setData('type', randomType);
    }, null, this);
  }
  
  if (currentTime > 10 && Math.random() < 0.35) {
    const positions = Phaser.Utils.Array.Shuffle([60, 120, 180, 240, 300, 360, 420]).slice(0, 2);
    positions.forEach((position, i) => {
      this.time.delayedCall(500 + i * 400, () => {
        if (gameOver) return;

        const typeRng = Math.random();
        let randomType = typeRng < 0.5 ? 'shiro_coin' : Phaser.Utils.Array.GetRandom(['bitcoin', 'ethereum', 'solana']);

        const coin = coins.create(position, 0, randomType);
        coin.setVelocityY(dropSpeed);
        coin.setDisplaySize(30, 30);
        coin.setData('type', randomType);
      }, null, this);
    });
  }
  
  if (currentTime > 30 && Math.random() < 0.15) {
    const positions = Phaser.Utils.Array.Shuffle([80, 160, 240, 320, 400]).slice(0, 2);
    positions.forEach((position, i) => {
      this.time.delayedCall(1000 + i * 400, () => {
        if (gameOver) return;

        let randomType = Math.random() < 0.6 ? 'shiro_coin' :
          Phaser.Utils.Array.GetRandom(['bitcoin', 'ethereum', 'solana']);

        const coin = coins.create(position, 0, randomType);
        coin.setVelocityY(dropSpeed);
        coin.setDisplaySize(30, 30);
        coin.setData('type', randomType);
      }, null, this);
    });
  }
}

function collectCoin(shiro, coin) {
  const type = coin.getData('type');
  let pointsChange = 0;

  if (type === 'shiro_coin') {
    pointsChange = 2;
    score += pointsChange;
    scoreText.setText('Puntos: ' + score);
    soundEffects.positive.play();

    const flash = this.add.image(coin.x, coin.y, 'hit');
    flash.setScale(0.1);
    this.tweens.add({
      targets: flash,
      alpha: 0,
      scale: 0.3,
      duration: 300,
      onComplete: () => flash.destroy()
    });
  } else {
    pointsChange = -1;
    score += pointsChange;
    scoreText.setText('Puntos: ' + score);
    soundEffects.negative.play();
  }
  
  const pointsText = this.add.text(coin.x, coin.y, pointsChange > 0 ? '+'+pointsChange : pointsChange, {
    fontSize: '20px',
    fontFamily: 'Arial',
    fill: pointsChange > 0 ? '#00ff00' : '#ff0000',
    stroke: '#000',
    strokeThickness: 2
  });
  
  this.tweens.add({
    targets: pointsText,
    y: coin.y - 30,
    alpha: 0,
    duration: 800,
    onComplete: () => pointsText.destroy()
  });

  coin.destroy();
}

// ✅ FUNCIÓN ENDGAME PERFECCIONADA
function endGame() {
  if (gameOver) return; 
  gameOver = true;

  console.log('🎯 FINALIZANDO JUEGO CON SCORE:', score);

  if (coinDropEvent) {
    coinDropEvent.remove(false);
    coinDropEvent = null;
  }

  const musicSound = this.sound.get('music');
  if (musicSound) musicSound.stop();
  
  if (soundEffects && soundEffects.gameOver) {
    soundEffects.gameOver.play();
  }

  this.physics.pause();
  
  this.time.delayedCall(2000, () => {
    if (shiro) shiro.setVisible(false);
    
    this.add.text(120, 300, 'GAME OVER', {
      fontSize: '48px',
      fill: '#ff0000',
      fontFamily: 'Arial',
      stroke: '#000',
      strokeThickness: 3,
    }).setDepth(100);

    this.add.text(180, 380, `TOTAL: ${score}`, {
      fontSize: '32px',
      fill: '#fff',
      fontFamily: 'Arial',
      stroke: '#000',
      strokeThickness: 2
    }).setDepth(100);

    restartButton = this.add.image(240, 520, 'restart_icon')
      .setDisplaySize(100, 100)
      .setInteractive()
      .setDepth(100);

    restartButton.on('pointerdown', () => {
      gameTime = 0;
      currentTime = 0;
      dropSpeed = 450;
      this.sound.stopAll();
      this.scene.restart();
    });

    // 🎮 ENVIAR SCORE OFICIAL DE TELEGRAM GAMES
    console.log('🎯 ENVIANDO SCORE OFICIAL A TELEGRAM GAMES:', score);
    
    try {
      if (typeof sendOfficialScore === 'function') {
        sendOfficialScore(score);
        
        this.add.text(120, 450, '🎮 Score enviado a Telegram!', {
          fontSize: '16px',
          fill: '#00ff00',
          fontFamily: 'Arial',
          stroke: '#000',
          strokeThickness: 2
        }).setDepth(100);
        
        this.add.text(80, 480, '📤 Usa el botón Compartir para publicar', {
          fontSize: '12px',
          fill: '#ffff00',
          fontFamily: 'Arial',
          stroke: '#000',
          strokeThickness: 1
        }).setDepth(100);
        
      } else {
        console.log('⚠️ sendOfficialScore no disponible - usando backup');
        throw new Error('Función oficial no disponible');
      }
      
    } catch (error) {
      console.error('❌ Error con score oficial, usando backup:', error);
      
      // 🔄 FALLBACK AL SISTEMA BACKUP
      fetch('https://shiro-game-bot.fly.dev/api/score', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          userId: 'player_' + Date.now(),
          username: 'Jugador_' + Math.floor(Math.random() * 1000),
          score: score,
          timestamp: Date.now()
        })
      })
      .then(response => {
        console.log('📡 Response status:', response.status);
        return response.json();
      })
      .then(data => {
        console.log('✅ SCORE BACKUP ENVIADO:', data);
        
        if (data.updated) {
          this.add.text(120, 450, '🎉 ¡Nuevo récord backup!', {
            fontSize: '16px',
            fill: '#00ff00',
            fontFamily: 'Arial',
            stroke: '#000',
            strokeThickness: 2
          }).setDepth(100);
        } else {
          this.add.text(100, 450, 'Score backup registrado', {
            fontSize: '16px',
            fill: '#ffff00',
            fontFamily: 'Arial',
            stroke: '#000',
            strokeThickness: 2
          }).setDepth(100);
        }
        
        this.add.text(130, 480, 'Usa /ranking para ver', {
          fontSize: '12px',
          fill: '#ffffff',
          fontFamily: 'Arial',
          stroke: '#000',
          strokeThickness: 1
        }).setDepth(100);
      })
      .catch(error => {
        console.error('❌ Error enviando score backup:', error);
        
        this.add.text(100, 450, '❌ Error enviando score', {
          fontSize: '16px',
          fill: '#ff0000',
          fontFamily: 'Arial',
          stroke: '#000',
          strokeThickness: 2
        }).setDepth(100);
        
        this.add.text(80, 480, 'Usa /testscore ' + score + ' manualmente', {
          fontSize: '12px',
          fill: '#ffff00',
          fontFamily: 'Arial',
          stroke: '#000',
          strokeThickness: 1
        }).setDepth(100);
      });
    }
    
  }, null, this);
}
